1,实际上是数R的个数
2,模拟一下，但要使用高精度，涉及到高精度比大小和高精度求差。
3,BFS
先预处理水的蔓延，f[i][j][k]表示j行k列在第I秒是不是水，用01表示即可。
然后做人的BFS处理。
4,f[i][j][k] 表示前i个mz，取j段时，0代表不取最后一个，1代表取最后一个
之所以要分取或不取，主要判断f[i][j][1]=max(f[i][j][1],f[i-1][j][1]+a[i]);
复制代码
 1 #include<iostream>
 2 using namespace std;
 3 
 4 const int INF=0x7fffffff;
 5 
 6 int n,ans=-INF;
 7 int a[1000001];
 8 int f[1000001][4][2];
 9 
10 int main()
11 {
12     scanf("%d",&n);;
13     for(int i=1;i<=n;i++) scanf("%d",&a[i]);
14     memset(f,0x8f,sizeof(f));
15     f[1][0][0]=0;f[1][1][1]=a[1];
16     for(int i=2;i<=n;i++)
17         for(int j=0;j<=3;j++)
18         {
19             f[i][j][0]=max(f[i-1][j][0],f[i-1][j][1]);
20             if(j>0) f[i][j][1]=max(f[i-1][j-1][0]+a[i],f[i-1][j-1][1]+a[i]);
21             f[i][j][1]=max(f[i][j][1],f[i-1][j][1]+a[i]);
22         }
23     for(int i=1;i<=n;i++)
24         ans=max(max(ans,f[i][3][0]),f[i][3][1]);
25     printf("%d\n",ans);
26     return 0;
27 }


5
此题非常蛋疼。。。

50分n很小，才20，对位置进行状压，复杂度是O(nm*2^n)。

注意到题目中的是区间修改，把沿途的位置取反，这个可以看做是在模2意义下，给区间的加一操作。在我们通常的思路中，对于区间的操作，原本是要修改区间长度个的位置的情况，我们都可以通过考虑它的差分序列，使得要修改的位置个数变成2个，我们要求最少的修改，使得原序列变成全0。

所以对原序列进行差分，那么每次修改就是要你对i号位置和i+size[]模2意义下的加1。

差分后的序列中，数值为1的个数是不会超过2k个，即不会超过20个。

考虑每次对i和i+x改动的过程，如果原序列中，i号位置和i+x号位置都是0的话，我们这么改，没有任何必要。所以任意时刻，数值为1的位置个数是不会增加的，那么我们可以把每一个的1看成一个的石子，那么每次我们可以把石子往某个方向移动size[]步，如果移动之后的位置存在石子的话，就对对碰，消掉了。

因为是对对碰，石子之间的关系肯定是一个匹配的关系，我们不妨求出Dist[i][j]表示，石子i要走到石子j的位置，至少需要移动多少步，那么我们可以枚举每一个石子，然后进行一遍的bfs即可，这一部分的复杂度是O(2kmn)。

现在问题转化为有一个大小不超过20的完全图，我们想要求它的最小权最大匹配。

对于70%的数据，直接暴力搜即可。

――――――――――-以下为错误算法――――――――――――C

然后可以将每个点拆成俩个点x，x’，能匹配的点xy从x向y’连边权值为1费用Dist[i][j]，源点向x连边，x’向汇连边，都是权值1费用0，然后一遍最小费用最大流就可以出解，但是发现这样是不能排除掉无解的情况的

比如6个点，每3个点互相都可以匹配，这样费用流是可以得到解的，但是显然无法两两配对，所幸数据中无解的情况只有一组。。。90分。。。

其实费用流的方法本身就是有问题的。。。一般图的带权匹配要用带花树解决，流算法不知道到底有多少可取之处，算是一种骗分吧

――――――――――-以上为错误算法――――――――――――C

100%的做法因为完全图的个数非常小，直接状压DP即可。对于一个状态，我们考虑其下标最小的那个位置和谁匹配了，就能递归成子问题了，复杂度是O(2kmn+2k*2^(2k))。